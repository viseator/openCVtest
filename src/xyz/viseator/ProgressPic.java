package xyz.viseator;import org.opencv.core.*;import org.opencv.imgcodecs.Imgcodecs;import org.opencv.imgproc.Imgproc;import java.awt.image.BufferedImage;import java.awt.image.DataBufferByte;import java.util.ArrayList;import java.util.Collections;import static org.opencv.imgproc.Imgproc.*;/** * Wudi * viseator@gmail.com * Created by viseator on 2016/11/13. */public class ProgressPic {    //the minimum length of line when find the horizontal lines of table    private static final double Y_MINLINELENGTH = 1200;    //the threshold when find the horizontal lines of table    private static final int Y_THRESHOLD = 150;    //the max gap of the intermittent line    private static final double Y_MAXLINEGAP = 20;    //similar with above,using in find vertical lines    private static final int X_THRESHOLD = 0;    //similar with above,using in find vertical lines    private static final double X_MAXLINEGAP = 11;    //factor for the minimum length of line,X_MINLINELENGTH = image.height() * X_HEIGHT_FACTOR    private static final double X_HEIGHT_FACTOR = 0.65;    //padding for cut table to rows    private static final double PADDING_TOP_BOTTOM = 0;    private static final double PADDING_LEFT_RIGHT = 0.09;    //the scale of a character's width in picture's width    private static final double CHARACTER_SIZE = 0.019;    private static final double IMAGE_WIDTH = 2592.0;    private Mat srcPic;//source picture    private Mat dilateMuchPic;//dilate much for finding lines    private String path;//image path    private ArrayList<Mat> blockImages; //Store rows    private int colNum = -1; //when find a valid col:colNum++    private int tableNum;    private ArrayList<ArrayList<ArrayList<Mat>>> mats; //temp    private TableInfo tableInfo;    public TableInfo progress(String path, int tableNum) {        this.path = path;        this.tableNum = tableNum;        tableInfo = GetTableInfo.get(tableNum);        //read image from path using gray mode        srcPic = Imgcodecs.imread(path, Imgcodecs.CV_LOAD_IMAGE_GRAYSCALE);        mats = new ArrayList<>();//init        resizePic();        binarization();        deNoise();        cutImagesToRows();        cutImageToCols();        storeImagesToTableInfo();        return tableInfo;    }    /**     *  resize the picture to fixed width in other to get the proper width of characters     */    private void resizePic() {        double scale = IMAGE_WIDTH / srcPic.width();        Size size = new Size(srcPic.width() * scale, srcPic.height() * scale);        Mat tempPic = new Mat(size,CvType.CV_8UC1);        Imgproc.resize(srcPic,tempPic,size);        srcPic = tempPic;    }    /**     * binarization the srouce picture     */    private void binarization() {        //blockSize and C are the best parameters for table        Imgproc.adaptiveThreshold(srcPic, srcPic, 255, ADAPTIVE_THRESH_MEAN_C, THRESH_BINARY_INV, 27, 10);    }    /**     * remove the isolated point in the picture     * erode the picture to remove     * then dilate it to recover others     */    private void deNoise() {        //kernel for erode, size:the size of the erosion        Mat kernelErode = Imgproc.getStructuringElement(Imgproc.MORPH_ERODE, new Size(2, 2));        Imgproc.erode(srcPic, srcPic, kernelErode);        //kernel for dilate, size:the size off the dilation        Mat kernelDilate = Imgproc.getStructuringElement(Imgproc.MORPH_DILATE, new Size(2, 2));        Imgproc.dilate(srcPic, srcPic, kernelDilate);        //dilate much, for finding all lines        dilateMuchPic = new Mat();        Mat kernelDilateMuch = Imgproc.getStructuringElement(Imgproc.MORPH_DILATE, new Size(12, 12));        Imgproc.dilate(srcPic, dilateMuchPic, kernelDilateMuch);        Imgcodecs.imwrite("C:/Users/visea/Desktop/test/java/cut/afterDilate" +                ".jpg", srcPic);    }    /**     * cut images to rows and store in blockImages     */    private void cutImagesToRows() {        ArrayList<Double> lineYs = new ArrayList<>();        ArrayList<Double> uniqueLineYs = new ArrayList<>();        //lines:a special mat for find lines        Mat lines = new Mat();        //find lines and store in lines        Imgproc.HoughLinesP(dilateMuchPic, lines, 1, Math.PI / 180, Y_THRESHOLD,                Y_MINLINELENGTH, Y_MAXLINEGAP);        //get the lines information from lines and store in lineYs        for (int i = 0; i < lines.rows(); i++) {            double[] points = lines.get(i, 0);            double y1, y2;            //just need the horizontal lines            y1 = points[1];            y2 = points[3];            // if it slopes, get the average of them, store the y-coordinate            if (Math.abs(y1 - y2) < 30) {                lineYs.add((y1 + y2) / 2);            }        }        getUniqueLines(lineYs, uniqueLineYs, 10);        blockImages = new ArrayList<>();        for (int i = 0; i < uniqueLineYs.size(); i++) {            Rect rect;            double y = uniqueLineYs.get(i);            //if not the last line            if (i != uniqueLineYs.size() - 1) {                rect = new Rect((int) (srcPic.width() * PADDING_LEFT_RIGHT),                        (int) (y + (uniqueLineYs.get(i + 1) - y) * PADDING_TOP_BOTTOM),                        (int) (srcPic.width() * (1 - PADDING_LEFT_RIGHT * 2)),                        (int) ((uniqueLineYs.get(i + 1) - y) * (1 - PADDING_TOP_BOTTOM * 2)));            } else {                //the last line                rect = new Rect((int) (srcPic.width() * PADDING_LEFT_RIGHT),                        (int) (y + (srcPic.height() - y) * PADDING_TOP_BOTTOM),                        (int) (srcPic.width() * (1 - PADDING_LEFT_RIGHT * 2)),                        (int) ((srcPic.height() - y) * (1 - PADDING_TOP_BOTTOM * 2)));            }            //cut the source picture to cutMat            Mat cutMat = new Mat(srcPic, rect);            blockImages.add(cutMat);        }    }    /**     * cut the rows in blockImages to cols     */    private void cutImageToCols() {        for (int position = 0; position < blockImages.size(); position++) {            Mat image = blockImages.get(position);            //dilate much to find all lines            dilateMuchPic = new Mat();            Mat kernelDilateMuch = Imgproc.getStructuringElement(Imgproc.MORPH_DILATE, new Size(6, 6));            Imgproc.dilate(image, dilateMuchPic, kernelDilateMuch);            //find lines            Mat lines = new Mat();            Imgproc.HoughLinesP(dilateMuchPic, lines, 0.1, Math.PI / 360, X_THRESHOLD,                    image.height() * X_HEIGHT_FACTOR, X_MAXLINEGAP);            ArrayList<Double> lineXs = new ArrayList<>();            for (int i = 0; i < lines.rows(); i++) {                double[] points = lines.get(i, 0);                double x1, x2;                x1 = points[0];                x2 = points[2];                if (Math.abs(x1 - x2) < 50) {                    lineXs.add((((x1 + x2) / 2)));//store the x-coordinate                }            }            ArrayList<Double> uniqueLineXs = new ArrayList<>();            getUniqueLines(lineXs, uniqueLineXs, 10);            //filter the invalid lines            ArrayList<Double> betterLineXs = new ArrayList<>();            filterLines(uniqueLineXs, betterLineXs, image.width());            //filter the image that have too much or too less lines or too small height            if (betterLineXs.size() < 2 || betterLineXs.size() > 5 || image.height() < srcPic.height() * 0.015) {                continue;            }            //find a valid image            colNum++;            showMarkedLines(image, betterLineXs);            cutImages(betterLineXs, image);        }    }    private void showMarkedLines(Mat src, ArrayList<Double> lines) {        Mat showLines = new Mat();        Imgproc.cvtColor(src, showLines, COLOR_GRAY2BGR);        for (double x : lines) {            Point pt1 = new Point(x, 0);            Point pt2 = new Point(x, src.height());            Imgproc.line(showLines, pt1, pt2, new Scalar(0, 0, 255), 3);        }        Imgcodecs.imwrite("C:/Users/visea/Desktop/test/java/cut/" +                String.valueOf(tableNum) + "_" +                String.valueOf(colNum) +                ".jpg", showLines);    }    /**     * filter the source coordinates, if some values are too close ,get the average of them     *     * @param src    source coordinates list     * @param dst    destination coordinate list     * @param minGap the minimum gap between coordinates     */    private void getUniqueLines(ArrayList<Double> src, ArrayList<Double> dst, int minGap) {        Collections.sort(src); //sort the sourc `e coordinates list        for (int i = 0; i < src.size(); i++) {            double sum = src.get(i);            double num = 1;            //when the distance between lines less than minGap, get the average of them            while (i != src.size() - 1 && src.get(i + 1) - src.get(i) < minGap) {                num++;                sum = sum + src.get(i + 1);                i++;            }            if (num == 1) {                dst.add(src.get(i));            } else {                dst.add(((sum / num)));            }        }    }    /**     * get the left and right borders of some continuous lines     *     * @param src         source of coordinates list     * @param dst         destination of coordinates list, the border will be stored like (start - end - start - end ...)     * @param maxGap      the maximum gap between adjacent lines that can be considered as continuous lines     * @param minDistance the minimum distance between start border and end border     */    private void getBorders(ArrayList<Double> src, ArrayList<Double> dst, int maxGap, int minDistance) {        Collections.sort(src);        for (int i = 0; i < src.size(); i++) {            double start = src.get(i);            double end = src.get(i);            //when the distance between two lines less than 10,get the average of them            while (i != src.size() - 1 && src.get(i + 1) - src.get(i) < maxGap) {                end = src.get(i + 1);                i++;            }            if (end - start >= minDistance) {                dst.add(start);                dst.add(end);            }        }    }    /**     * if the gap between lines less than filterGap*width, reserve the first of them and filter out others     *     * @param src   source coordinates list     * @param dst   destination coordinates list     * @param width the width of image     */    private void filterLines(ArrayList<Double> src, ArrayList<Double> dst, int width) {        for (int i = 0; i < src.size(); i++) {            int recode = i;            while (i != src.size() - 1 && src.get(i + 1) - src.get(i) <                    width * tableInfo.getRows(colNum + 1).getFilterGap()) {                i++;            }            dst.add(src.get(recode));        }    }    /**     * cut the rows to cells     *     * @param lineXs the x-coordinates list represents lines,     *               the content between start bound and end bound will be cut and passed on to next step     * @param image  the rows to be cut     */    private void cutImages(ArrayList<Double> lineXs, Mat image) {        Mat cutMat = new Mat(image, new Rect((int) (lineXs.get(tableInfo.getRows(colNum).getBoundLeft()) + 5),                0,                (int) (lineXs.get(tableInfo.getRows(colNum).getBorderRight()) -                        lineXs.get(tableInfo.getRows(colNum).getBoundLeft())) - 10, image.height()));        mats.add(cutSingleLine(cutMat));    }    /**     * cut the content of cells to single lines     *     * @param srcMat source image to be cut     * @return single lines,every single line include single characters or just lines(when the content is number)     */    private ArrayList<ArrayList<Mat>> cutSingleLine(Mat srcMat) {        ArrayList<ArrayList<Mat>> singleLines = new ArrayList<>();        //store the y-coordinates of empty rows (which has few white pixel)        ArrayList<Double> emptyRows = new ArrayList<>();        ArrayList<Double> uniqueEmptyRows = new ArrayList<>();        //walking all of pixels of each rows, when the count of white pixels less than 3, store the y-coordinate of row        double[] points;        for (int row = 0; row < srcMat.rows(); row++) {            int count = 0;            for (int col = 0; col < srcMat.cols(); col++) {                points = srcMat.get(row, col);                if (points[0] == 255) {                    count++;                }            }            if (count < 3) emptyRows.add((double) row);        }        getUniqueLines(emptyRows, uniqueEmptyRows, 10);        //if the start border or end border are not found because of the slope table border, add them manually        if (uniqueEmptyRows.get(0) > srcMat.height() * 0.3)            uniqueEmptyRows.add(0, 0.0);        if (uniqueEmptyRows.get(uniqueEmptyRows.size() - 1) < srcMat.height() * 0.7)            uniqueEmptyRows.add((double) (srcMat.height() - 1));        //if the content is number, store the whole cell to singeLines        ArrayList<Mat> linesInCol = new ArrayList<>();        for (int i = 0; i < uniqueEmptyRows.size(); i++) {            if (i != uniqueEmptyRows.size() - 1) {                Mat cutMat = new Mat(srcMat, new Rect(0,                        (uniqueEmptyRows.get(i).intValue()),                        srcMat.width(),                        (((int) (uniqueEmptyRows.get(i + 1) - uniqueEmptyRows.get(i))))));                //if data type is number                if (tableInfo.getRows(colNum).getDataType() <= 1) {                    linesInCol.add(cutMat);                    Imgcodecs.imwrite("C:/Users/visea/Desktop/test/java/cut/cut/" +                            String.valueOf(tableNum) + "_" +                            String.valueOf(colNum) +                            ".jpg", cutMat);                } else {//else we should cut them to single characters                    singleLines.add(cutSingleCha(cutMat,i));                }            }        }        if (tableInfo.getRows(colNum).getDataType() <= 1) singleLines.add(linesInCol);        return singleLines;    }    /**     * cut the Chinese lines to single characters     * similar with cutSingleLines above     *     * @param srcMat source image     * @return list of characters     */    private ArrayList<Mat> cutSingleCha(Mat srcMat, int testNum) {        ArrayList<Mat> characters = new ArrayList<>();        ArrayList<Double> emptyCols = new ArrayList<>();        ArrayList<Double> uniqueEmptyCols = new ArrayList<>();        double[] points;        for (int col = 0; col < srcMat.cols(); col++) {            int count = 0;            for (int row = 0; row < srcMat.rows(); row++) {                points = srcMat.get(row, col);                if (points[0] == 255) {                    count++;                }            }            if (count < 3) emptyCols.add((double) col);        }        getBorders(emptyCols, uniqueEmptyCols, 5, 2);        //cut the image according to the left and right borders        for (int i = 1; i < uniqueEmptyCols.size() - 1; i += 2) {            Mat cutMat = new Mat();            if (i < uniqueEmptyCols.size() - 3) {                /**                 *    if the right border - the left border < character's size - 10, and the next right border - this left                 *  border < character's size + 5, consider it as a single character be separated to two part                 */                if (uniqueEmptyCols.get(i + 1) - uniqueEmptyCols.get(i) < srcPic.width() * CHARACTER_SIZE - 10 &&                        uniqueEmptyCols.get(i + 3) - uniqueEmptyCols.get(i) < srcPic.width() * CHARACTER_SIZE + 5                        ) {                    //jump to the next right border                    cutMat = new Mat(srcMat, new Rect(uniqueEmptyCols.get(i).intValue(),                            0,                            (int) (uniqueEmptyCols.get(i + 3) - uniqueEmptyCols.get(i)),                            srcMat.height()));                    i += 2;                } else {                    cutMat = new Mat(srcMat, new Rect(uniqueEmptyCols.get(i).intValue(),                            0,                            (int) (uniqueEmptyCols.get(i + 1) - uniqueEmptyCols.get(i)),                            srcMat.height()));                }            } else if (i != uniqueEmptyCols.size() - 1) {                cutMat = new Mat(srcMat, new Rect(uniqueEmptyCols.get(i).intValue(),                        0,                        (int) (uniqueEmptyCols.get(i + 1) - uniqueEmptyCols.get(i)),                        srcMat.height()));            }            characters.add(cutMat);            Imgcodecs.imwrite("C:/Users/visea/Desktop/test/java/cut/cut/" +                    String.valueOf(tableNum) + "_" +                    String.valueOf(colNum) + "_" +                    String.valueOf(testNum) + "_" +                    String.valueOf(i) +                    ".jpg", cutMat);        }        return characters;    }    /**     * convert Mat format to bufferedImage format for OCR     *     * @param mat     * @return     */    private BufferedImage convertMatToBufferedImage(Mat mat) {        BufferedImage bufferedImage = new BufferedImage(mat.width(), mat.height(), BufferedImage.TYPE_BYTE_GRAY);        byte[] data = ((DataBufferByte) bufferedImage.getRaster().getDataBuffer()).getData();        mat.get(0, 0, data);        return bufferedImage;    }    /**     * store images to rows in the tableInfo     */    private void storeImagesToTableInfo() {        for (int colId = 0; colId < tableInfo.getRowsSize(); colId++) {            ArrayList<ArrayList<Mat>> col = mats.get(colId);            ArrayList<BufferedImage> characters = new ArrayList<>();            for (ArrayList<Mat> singleLine : col) {                for (Mat character : singleLine) {                    BufferedImage bufferedImage = convertMatToBufferedImage(character);                    characters.add(bufferedImage);                }            }            tableInfo.getRows(colId).setBufferedImages(characters);        }    }}